From 2e9bb4fe815104c78e205660dea0a2e8d0278b9a Mon Sep 17 00:00:00 2001
From: Suman Mukherjee <sumam@codeaurora.org>
Date: Thu, 22 Sep 2016 03:36:48 +0000
Subject: [PATCH] msm: sensor: validate the i2c table index before use

Verifying the i2c table index value before accessing
the i2c table to avoid memory corruption issues.
CRs-Fixed: 1065916

Change-Id: I0e31c22f90006f27a77cd420288334b8355cee95
Signed-off-by: Sureshnaidu Laveti <lsuresh@codeaurora.org>
Signed-off-by: Suman Mukherjee <sumam@codeaurora.org>
---

diff --git a/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c b/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c
index d056c7e..ed52255 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c
@@ -145,11 +145,6 @@
 	CDBG("Enter cam_name=%d\n", a_ctrl->cam_name);
 
 	for (i = 0; i < size; i++) {
-		/* check that the index into i2c_tbl cannot grow larger that
-		the allocated size of i2c_tbl */
-		if ((a_ctrl->total_steps + 1) < (a_ctrl->i2c_tbl_index)) {
-			break;
-		}
 		if (write_arr[i].reg_write_type == MSM_ACTUATOR_WRITE_DAC) {
 			value = (next_lens_position <<
 				write_arr[i].data_shift) |
@@ -164,6 +159,11 @@
 						i2c_byte2 = value & 0xFF;
 						CDBG("byte1:0x%x, byte2:0x%x\n",
 							i2c_byte1, i2c_byte2);
+						if (a_ctrl->i2c_tbl_index >
+							a_ctrl->total_steps) {
+							pr_err("failed:i2c table index out of bound\n");
+							break;
+						}
 						i2c_tbl[a_ctrl->i2c_tbl_index].
 							reg_addr = i2c_byte1;
 						i2c_tbl[a_ctrl->i2c_tbl_index].
@@ -184,6 +184,11 @@
 						i2c_byte2 = i2c_byte2 & 0xFF;
 						CDBG("byte1:0x%x, byte2:0x%x\n",
 							i2c_byte1, i2c_byte2);
+						if (a_ctrl->i2c_tbl_index >
+							a_ctrl->total_steps) {
+							pr_err("failed:i2c table index out of bound\n");
+							break;
+						}
 						i2c_tbl[a_ctrl->i2c_tbl_index].
 							reg_addr = i2c_byte1;
 						i2c_tbl[a_ctrl->i2c_tbl_index].
@@ -205,6 +210,10 @@
 			i2c_byte2 = (hw_dword & write_arr[i].hw_mask) >>
 				write_arr[i].hw_shift;
 		}
+		if (a_ctrl->i2c_tbl_index > a_ctrl->total_steps) {
+			pr_err("failed: i2c table index out of bound\n");
+			break;
+		}
 		CDBG("i2c_byte1:0x%x, i2c_byte2:0x%x\n", i2c_byte1, i2c_byte2);
 		i2c_tbl[a_ctrl->i2c_tbl_index].reg_addr = i2c_byte1;
 		i2c_tbl[a_ctrl->i2c_tbl_index].reg_data = i2c_byte2;
